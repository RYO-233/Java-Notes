[toc]

# Lock

## 互斥锁

### 基本介绍

> 1. 在 Java 语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。
> 2. 每个对象都对应于一个可称为 “互斥锁” 的标记。这个标记用来保证在任一时刻，只能有一个线程访问该对象。
> 3. 关键字 `synchronized` 用来与对象的互斥锁联系。当某个对象用 `synchronized` 修饰时，表明该对象在任一时刻只能由一个线程访问。
> 4. 同步的局限性: 
>     导致程序的执行效率降低。
> 5. (非静态的)同步方法的锁可以是 this，也可以是其他对象(要求是同一个对象)
> 6. (静态的)同步方法的锁为当前类本身。

### 注意事项

1. 同步方法如果没有使用 static 修饰: 默认锁对象为 this。
2. 如果方法使用 static 修饰: 默认锁对象为 当前类.class。
3. 实现的落地步骤:
    1. 需要先分析上锁的代码。
    2. 选择同步代码块 / 同步方法。
    3. 要求多个线程的锁对象为同一个即可。

## 死锁

### 基本介绍

> ​	多个线程都占用了对方的锁资源，不肯相让，导致死锁。
> ​	要避免死锁。

## 释放锁

### 以下操作会释放锁

> 1. 当前线程的同步代码块、同步方法执行结束。
>     案例: 上厕所，完事出来。
> 2. 当前线程在同步代码块、同步方法中遇到 `break、return`。
>     案例: 没有正常的完事,经理叫他修改 bug，不得已出来。
> 3. 当前线程在同步代码块、同步方法中出现了未处理的 `Error / Exception`，导致异常结束。
>     案例: 没有正常的完事，发现忘带纸，不得已出来。
> 4. 当前线程在同步代码块、同步方法中执行了线程对象的 `wait()` 方法，当前线程暂停，并释放锁。
>     案例: 没有正常完事，觉得需要酝酿下，所以出来等会再进去。

### 以下操作不会释放锁

> 1. 线程执行同步代码块、同步方法时，程序调用`Thread.sleep()、Thread.yield` 方法暂停当前线程的执行。不会释放锁。
>     案例: 上厕所，太困了，在坑位上眯了一会。
> 2. 线程执行同步代码块时，其他线程调用了该线程的 `suspend()` 方法，将该线程挂起，该线程不会释放锁。
>     提示: 应尽量避免使用 `suspend()` 和 `resume()` 来控制线程，方法不再推荐使用。
